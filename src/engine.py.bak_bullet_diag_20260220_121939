
# ===== BULLET + STOCHASTIC LIQUIDITY VERSION =====

import numpy as np
import pandas as pd

def _sample_params(rng, cfg):
    re = cfg["risk_engine"]

    Z = rng.normal()
    e1, e2, e3 = rng.normal(size=3)

    z_default = np.sqrt(re["rho_default"]) * Z + np.sqrt(1 - re["rho_default"]) * e1
    z_lgd = np.sqrt(re["rho_lgd"]) * Z + np.sqrt(1 - re["rho_lgd"]) * e2
    z_margin = np.sqrt(re["rho_margin"]) * Z + np.sqrt(1 - re["rho_margin"]) * e3

    default_rate = re["default_rate"]["base"] + re["default_rate"]["shock_coef"] * (-z_default)
    default_rate = float(np.clip(default_rate,
                                 re["default_rate"]["clip_min"],
                                 re["default_rate"]["clip_max"]))

    lgd = re["lgd"]["base"] + re["lgd"]["shock_coef"] * (-z_lgd)
    lgd = float(np.clip(lgd,
                        re["lgd"]["clip_min"],
                        re["lgd"]["clip_max"]))

    margin_shock = re["margin_shock"]["shock_coef"] * z_margin
    margin_shock = float(np.clip(margin_shock,
                                 re["margin_shock"]["clip_min"],
                                 re["margin_shock"]["clip_max"]))

    return default_rate, lgd, margin_shock


def _simulate_one_path(cfg, default_rate, lgd, margin_shock, rng):

    H = cfg["sim"]["H"]
    notional = cfg["portfolio"]["notional"]
    funding_cfg = cfg.get("funding", {})

    A_limit = notional * 0.6
    B_limit = notional * 0.2
    C_limit = notional * 0.1

    A_bal = B_bal = C_bal = 0.0
    WH_bal = notional

    coupon = cfg["portfolio"]["annual_coupon_rate"] + margin_shock
    coupon_m = coupon / 12

    A_rate = 0.05 / 12
    B_rate = 0.07 / 12
    C_rate = 0.10 / 12
    WH_rate = 0.08 / 12

    p_freeze_start = funding_cfg.get("p_freeze_start", 0.0)
    p_freeze_persist = funding_cfg.get("p_freeze_persist", 0.0)
    freeze_draw_factor = funding_cfg.get("freeze_draw_factor", 1.0)
    wh_limit = funding_cfg.get("wh_limit", notional)
    liquidity_shortfall_rate = funding_cfg.get("liquidity_shortfall_rate", 0.0)

    term_years = H / 12
    p_default_term = 1 - (1 - default_rate) ** term_years

    total_income = 0.0
    outstanding = notional

    in_freeze = False
    freeze_months = 0

    for t in range(H):

        if in_freeze:
            in_freeze = (rng.random() < p_freeze_persist)
        else:
            in_freeze = (rng.random() < p_freeze_start)

        if in_freeze:
            freeze_months += 1

        if t > 0:
            funding_needed = outstanding - (A_bal + B_bal + C_bal)

            draw_factor = freeze_draw_factor if in_freeze else 1.0

            draw_A = min((A_limit - A_bal) * draw_factor, funding_needed)
            A_bal += draw_A
            funding_needed -= draw_A

            draw_B = min((B_limit - B_bal) * draw_factor, funding_needed)
            B_bal += draw_B
            funding_needed -= draw_B

            draw_C = min((C_limit - C_bal) * draw_factor, funding_needed)
            C_bal += draw_C
            funding_needed -= draw_C

            residual = max(outstanding - (A_bal + B_bal + C_bal), 0)
            WH_bal = min(residual, wh_limit)

        interest_income = outstanding * coupon_m

        is_maturity = (t == H - 1)

        loss_t = 0.0
        if is_maturity:
            D = 1 if rng.random() < p_default_term else 0
            loss_t = notional * D * lgd
            outstanding = 0

        funding_cost = (
            A_bal * A_rate +
            B_bal * B_rate +
            C_bal * C_rate +
            WH_bal * WH_rate
        )

        total_income += (interest_income - funding_cost - loss_t)

    return {
        "total_net_income": total_income,
        "default_rate": default_rate,
        "lgd": lgd,
        "margin_shock": margin_shock,
        "freeze_months": freeze_months
    }


def run_mc(cfg):
    rng = np.random.default_rng(cfg["seed"])
    N = cfg["sim"]["N"]

    records = []
    for _ in range(N):
        dr, lgd, ms = _sample_params(rng, cfg)
        records.append(_simulate_one_path(cfg, dr, lgd, ms, rng))

    return pd.DataFrame(records)
